index.js:1:import makeWASocket, { DisconnectReason, fetchLatestBaileysVersion, useMultiFileAuthState } from "baileys";
index.js:7:    const { state, saveCreds } = await useMultiFileAuthState('auth_info');
node_modules\baileys\lib\Socket\business.js:7:    const { authState, query, waUploadToServer } = sock;
node_modules\baileys\lib\Socket\business.js:9:        jid = jid || authState.creds.me?.id;
node_modules\baileys\lib\Socket\business.js:56:        jid = jid || authState.creds.me?.id;
node_modules\baileys\lib\Socket\chats.js:17:    const { ev, ws, authState, generateMessageTag, sendNode, query, onUnexpectedError } = sock;
node_modules\baileys\lib\Socket\chats.js:34:        const { [keyId]: key } = await authState.keys.get('app-state-sync-key', [keyId]);
node_modules\baileys\lib\Socket\chats.js:185:        if (jidNormalizedUser(jid) !== jidNormalizedUser(authState.creds.me.id)) {
node_modules\baileys\lib\Socket\chats.js:215:        if (jidNormalizedUser(jid) !== jidNormalizedUser(authState.creds.me.id)) {
node_modules\baileys\lib\Socket\chats.js:355:                processSyncAction(mutation, ev, authState.creds.me, isInitialSync ? { accountSettings: authState.creds.accountSettings } : undefined, logger);
node_modules\baileys\lib\Socket\chats.js:364:        await authState.keys.transaction(async () => {
node_modules\baileys\lib\Socket\chats.js:375:                    const result = await authState.keys.get('app-state-sync-version', [name]);
node_modules\baileys\lib\Socket\chats.js:423:                            await authState.keys.set({ 'app-state-sync-version': { [name]: newState } });
node_modules\baileys\lib\Socket\chats.js:428:                            await authState.keys.set({ 'app-state-sync-version': { [name]: newState } });
node_modules\baileys\lib\Socket\chats.js:448:                        await authState.keys.set({ 'app-state-sync-version': { [name]: null } });
node_modules\baileys\lib\Socket\chats.js:485:        const me = authState.creds.me;
node_modules\baileys\lib\Socket\chats.js:572:        const myAppStateKeyId = authState.creds.myAppStateKeyId;
node_modules\baileys\lib\Socket\chats.js:579:            await authState.keys.transaction(async () => {
node_modules\baileys\lib\Socket\chats.js:582:                const { [name]: currentSyncVersion } = await authState.keys.get('app-state-sync-version', [name]);
node_modules\baileys\lib\Socket\chats.js:618:                await authState.keys.set({ 'app-state-sync-version': { [name]: state } });
node_modules\baileys\lib\Socket\chats.js:643:                        hash: authState?.creds?.lastPropHash || ''
node_modules\baileys\lib\Socket\chats.js:653:                authState.creds.lastPropHash = propsNode?.attrs?.hash;
node_modules\baileys\lib\Socket\chats.js:654:                ev.emit('creds.update', authState.creds);
node_modules\baileys\lib\Socket\chats.js:767:            let jid = msg.key.fromMe ? authState.creds.me.id : msg.key.participant || msg.key.remoteJid;
node_modules\baileys\lib\Socket\chats.js:773:            if (msg.key.fromMe && msg.pushName && authState.creds.me?.name !== msg.pushName) {
node_modules\baileys\lib\Socket\chats.js:774:                ev.emit('creds.update', { me: { ...authState.creds.me, name: msg.pushName } });
node_modules\baileys\lib\Socket\chats.js:806:                const accountSyncCounter = (authState.creds.accountSyncCounter || 0) + 1;
node_modules\baileys\lib\Socket\chats.js:820:                creds: authState.creds,
node_modules\baileys\lib\Socket\chats.js:821:                keyStore: authState.keys,
node_modules\baileys\lib\Socket\chats.js:840:                    let { lastAccountSyncTimestamp } = authState.creds;
node_modules\baileys\lib\Socket\communities.js:9:    const { authState, ev, query, upsertMessage } = sock;
node_modules\baileys\lib\Socket\communities.js:279:                messageStubParameters: [authState.creds.me.id],
node_modules\baileys\lib\Socket\groups.js:8:    const { authState, ev, query, upsertMessage } = sock;
node_modules\baileys\lib\Socket\groups.js:240:                messageStubParameters: [authState.creds.me.id],
node_modules\baileys\lib\Socket\messages-recv.js:16:    const { ev, authState, ws, processingMutex, signalRepository, query, upsertMessage, resyncAppState, onUnexpectedError, assertSessions, sendNode, relayMessage, sendReceipt, uploadPreKeys, sendPeerDataOperationMessage } = sock;
node_modules\baileys\lib\Socket\messages-recv.js:58:            stanza.attrs.from = authState.creds.me.id;
node_modules\baileys\lib\Socket\messages-recv.js:67:                from: authState.creds.me.id,
node_modules\baileys\lib\Socket\messages-recv.js:85:        const { fullMessage } = decodeMessageNode(node, authState.creds.me.id, authState.creds.me.lid || '');
node_modules\baileys\lib\Socket\messages-recv.js:97:        const { account, signedPreKey, signedIdentityKey: identityKey } = authState.creds;
node_modules\baileys\lib\Socket\messages-recv.js:104:        await authState.keys.transaction(async () => {
node_modules\baileys\lib\Socket\messages-recv.js:125:                        content: encodeBigEndian(authState.creds.registrationId)
node_modules\baileys\lib\Socket\messages-recv.js:136:                const { update, preKeys } = await getNextPreKeys(authState, 1);
node_modules\baileys\lib\Socket\messages-recv.js:318:                if (areJidsSameUser(child.attrs.jid, authState.creds.me.id)) {
node_modules\baileys\lib\Socket\messages-recv.js:359:                            ...authState.creds.accountSettings,
node_modules\baileys\lib\Socket\messages-recv.js:382:                const companionSharedKey = Curve.sharedKey(authState.creds.pairingEphemeralKeyPair.private, codePairingPublicKey);
node_modules\baileys\lib\Socket\messages-recv.js:390:                    Buffer.from(authState.creds.signedIdentityKey.public),
node_modules\baileys\lib\Socket\messages-recv.js:397:                const identitySharedKey = Curve.sharedKey(authState.creds.signedIdentityKey.private, primaryIdentityPublicKey);
node_modules\baileys\lib\Socket\messages-recv.js:399:                authState.creds.advSecretKey = (await hkdf(identityPayload, 32, { info: 'adv_secret' })).toString('base64');
node_modules\baileys\lib\Socket\messages-recv.js:412:                                jid: authState.creds.me.id,
node_modules\baileys\lib\Socket\messages-recv.js:424:                                    content: authState.creds.signedIdentityKey.public
node_modules\baileys\lib\Socket\messages-recv.js:435:                authState.creds.registered = true;
node_modules\baileys\lib\Socket\messages-recv.js:436:                ev.emit('creds.update', authState.creds);
node_modules\baileys\lib\Socket\messages-recv.js:445:        const secretKey = await derivePairingCodeKey(authState.creds.pairingCode, salt);
node_modules\baileys\lib\Socket\messages-recv.js:477:            await authState.keys.set({ 'sender-key-memory': { [remoteJid]: null } });
node_modules\baileys\lib\Socket\messages-recv.js:503:        const isNodeFromMe = areJidsSameUser(attrs.participant || attrs.from, isLid ? authState.creds.me?.lid : authState.creds.me?.id);
node_modules\baileys\lib\Socket\messages-recv.js:590:                        const fromMe = areJidsSameUser(node.attrs.participant || remoteJid, authState.creds.me.id);
node_modules\baileys\lib\Socket\messages-recv.js:626:            const { key } = decodeMessageNode(node, authState.creds.me.id, authState.creds.me.lid || '').fullMessage;
node_modules\baileys\lib\Socket\messages-recv.js:638:        const { fullMessage: msg, category, author, decrypt } = decryptMessageNode(node, authState.creds.me.id, authState.creds.me.lid || '', signalRepository, logger);
node_modules\baileys\lib\Socket\messages-recv.js:698:                    cleanMessage(msg, authState.creds.me.id);
node_modules\baileys\lib\Socket\messages-recv.js:708:        if (!authState.creds.me?.id) {
node_modules\baileys\lib\Socket\messages-recv.js:724:        if (!authState.creds.me?.id) {
node_modules\baileys\lib\Socket\messages-send.js:14:    const { ev, authState, processingMutex, signalRepository, upsertMessage, query, fetchPrivacySettings, sendNode, groupMetadata, groupToggleEphemeral } = sock;
node_modules\baileys\lib\Socket\messages-send.js:145:            const extracted = extractDeviceJids(result?.list, authState.creds.me.id, ignoreZeroDevices);
node_modules\baileys\lib\Socket\messages-send.js:166:            const sessions = await authState.keys.get('session', addrs);
node_modules\baileys\lib\Socket\messages-send.js:201:        if (!authState.creds.me?.id) {
node_modules\baileys\lib\Socket\messages-send.js:210:        const meJid = jidNormalizedUser(authState.creds.me.id);
node_modules\baileys\lib\Socket\messages-send.js:255:        const meId = authState.creds.me.id;
node_modules\baileys\lib\Socket\messages-send.js:288:        await authState.keys.transaction(async () => {
node_modules\baileys\lib\Socket\messages-send.js:333:                            const result = await authState.keys.get('sender-key-memory', [jid]);
node_modules\baileys\lib\Socket\messages-send.js:393:                await authState.keys.set({ 'sender-key-memory': { [jid]: senderKeyMap } });
node_modules\baileys\lib\Socket\messages-send.js:412:                    const jid = jidEncode(isMe && isLid ? authState.creds?.me?.lid.split(':')[0] || user : user, isLid ? 'lid' : 's.whatsapp.net', device);
node_modules\baileys\lib\Socket\messages-send.js:478:                    content: encodeSignedDeviceIdentity(authState.creds.account, true)
node_modules\baileys\lib\Socket\messages-send.js:589:            const meId = authState.creds.me.id;
node_modules\baileys\lib\Socket\messages-send.js:629:            const userJid = authState.creds.me.id;
node_modules\baileys\lib\Socket\socket.js:18:    const { waWebSocketUrl, connectTimeoutMs, logger, keepAliveIntervalMs, browser, auth: authState, printQRInTerminal, defaultQueryTimeoutMs, transactionOpts, qrTimeout, makeSignalRepository } = config;
node_modules\baileys\lib\Socket\socket.js:26:    if (url.protocol === 'wss' && authState?.creds?.routingInfo) {
node_modules\baileys\lib\Socket\socket.js:27:        url.searchParams.append('ED', authState.creds.routingInfo.toString('base64url'));
node_modules\baileys\lib\Socket\socket.js:39:        routingInfo: authState?.creds?.routingInfo
node_modules\baileys\lib\Socket\socket.js:41:    const { creds } = authState;
node_modules\baileys\lib\Socket\socket.js:43:    const keys = addTransactionCapability(authState.keys, logger, transactionOpts);
node_modules\baileys\lib\Socket\socket.js:328:        const jid = authState.creds.me?.id;
node_modules\baileys\lib\Socket\socket.js:356:        authState.creds.pairingCode = pairingCode;
node_modules\baileys\lib\Socket\socket.js:357:        authState.creds.me = {
node_modules\baileys\lib\Socket\socket.js:361:        ev.emit('creds.update', authState.creds);
node_modules\baileys\lib\Socket\socket.js:374:                        jid: authState.creds.me.id,
node_modules\baileys\lib\Socket\socket.js:387:                            content: authState.creds.noiseKey.public
node_modules\baileys\lib\Socket\socket.js:408:        return authState.creds.pairingCode;
node_modules\baileys\lib\Socket\socket.js:413:        const key = await derivePairingCodeKey(authState.creds.pairingCode, salt);
node_modules\baileys\lib\Socket\socket.js:414:        const ciphered = aesEncryptCTR(authState.creds.pairingEphemeralKeyPair.public, key, randomIv);
node_modules\baileys\lib\Socket\socket.js:504:        ev.emit('creds.update', { me: { ...authState.creds.me, lid: node.attrs.lid } });
node_modules\baileys\lib\Socket\socket.js:532:            authState.creds.routingInfo = Buffer.from(routingInfo?.content);
node_modules\baileys\lib\Socket\socket.js:533:            ev.emit('creds.update', authState.creds);
node_modules\baileys\lib\Socket\socket.js:576:        authState: { creds, keys },
node_modules\baileys\lib\Socket\socket.js:579:            return authState.creds.me;
node_modules\baileys\lib\Utils\use-multi-file-auth-state.js:23: * Far more efficient than singlefileauthstate
node_modules\baileys\lib\Utils\use-multi-file-auth-state.js:28:export const useMultiFileAuthState = async (folder) => {
